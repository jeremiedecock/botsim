TODO

Exemple de qualité physique et visuelle à atteindre: https://www.youtube.com/watch?v=BGAwRKPlpCw

x Utiliser eigen pour les vecteur donnés aux constructeurs des Objets
x MSAA
x Black background
x Light (directional ?)
x Ajouter et utiliser asseseurs dans Objects
x Ajouter des fonctions wrapper vec3_eigen_to_bullet, ...
x Renommer Objects -> Parts
x Séparer les modules
x Ombres
x Caméra
x Ajouter les fichiers AUTHORS et COPYING
x Remplacer le makefile par un cmakelist -> Créer une arborescence et des modules .h/.cpp
x Ajouter des matériaux pour les objets "Part"

- Key reset -> ajouter une méthode "reset()" dans "BulletEnvironment"
x Key print camera coordinates
x Key take screenshot
x Key start/stop recording -> screencast
x Add OSG fog

x Doxygen
x Permettre de configurer le refresh rate ou de passer en mode "temps réel" (-1)
x Améliorer le réalisme des simulations physiques
x Renommer le répertoire "simulation" -> "scenes"
  adapter le cmakelist pour créer plusieurs scenes co. ds metis (chaque scene = 1 exe)
+ Exporter un fichier stat (dat ou json ?)
  -> classe Log qui utilise le pattern Observateur (+ s'inspirer des logs de metis)
     - Part = sujet
     - LogJson / LogDat = observateur
     + faire un snippet C++
       snippets/cpp/designpatterns/doxyfile
                                   listener
                                       subject.cpp
                                       listener.cpp
                                   singleton
                                       ...
                                   ...
  -> systeme de log générique comme pour metis:
     - Simulation time, User time, Time step, Fixed sub time step, Sub steps, Max sub steps + FPS
     - Forces, accélérations, vitesse, position, énergie, ... des Parts
     - Forces, accélérations, vitesse, position, énergie, ... des Objets
+ Permettre de lancer une simulation sans interface graphique (sans osg)
  permetter de remplacer le "physicsCallback"
  ajouter une méthode run(time) dans BulletEnvironment qui ne fait qu'appeler autant de fois que nécessaire this->stepSimulation()
+ Vérifier le code physique, ...
+ Classe Object qui contient un vecteur de Parts

+ Charnières: classe "Hinge" qui hérite de "Part" + faire des démos
- Servomoteurs: classe "Actuator" qui hérite de la classe "Hinge"
  btHingeConstraint.enableAngularMotor(...)
+ Screencast : ajouter un option pour permettre de capturer les images à un framerate constant (de 25fps).
  créer une classe fille de osgViewer::ScreenCaptureHandler::WriteToFile avec un compteur de temps (attention: pas le temps réel mais le temps de la simulation)...

- Assesseurs pour les attributs des objets "Part", "BulletEnvironment" et "OSGEnvironment"
  -> Ajouter des assesseurs pour les propriétés physiques des objets "Part", "BulletEnvironment"
- Fonctions virtuelles pures dans Parts et Objects (Part et Object ne devraient pas être instanciables)
- Part est une classe abstraite, elle ne devrait pas pouvoir être instanciée -> au moins une fonction virtuelle pure (constructeur ?)
- Renommer correctement les variables (p_...) + utiliser les smart pointers sur tous les objets OSG + détruire correctement les autre objets + check memleak with Valgrind
- Scale units factor (mm ?, kg ?, ...)
- Compléter la doc en ligne (doxygen)

- Ajouter des objets: sphere, cylindre, etc. + faire des démos
- Objets STL (balle de golf, charnières 1DOF, charnières 2DOF, ...) + ceiling + faire des démos

- Senseurs -> créer une interface (ou une classe abstraite) "Sensor"
  -> accéléromètre (facile ?)
  -> position absolue/pseudo GPS (facile ?)
  -> odomètre (facile ?)
  -> gyroscope (facile ?)
  -> position angulaire des actuateurs (facile ?)
  -> caméra (difficile ?)
  -> capteurs de force/de contact/de pression (difficile ?)
  -> capteur de distance IR/ultrasons (difficile ?)
- Permettre de sauvegarder les données des senseurs (au format JSON ?) -> appliquer le pattern listener sur les hinge et actuators
- Créer un OSG_Bullet_Qt_Lab pour tester interactivement les propriétés physique des objets et du simulateur (des widgets permettent de "voir" immédiatement l'impact sur la simulation de la modification de certains paramètres)
  -> charnières: impulsions, mesure du couple appliqué, mesure de l'énergie donné en entrée/dissipée/etc., résistance, autres forces (centrifuge, ...)
  -> friction, frottements, ...
  -> énergie des objets (cinétique, potentielle, ...) + forces appliquées
  -> absorption/restitution de l'énergie lors des chocs
  -> soft bodies
  -> mesurer les vraies propriétés physique des charnières et des servo moteurs, les retranscrire sur les modèles numériques et comparer les simulations à la réalité sur des objets simples
  -> ...
- Vérifier à la main une simulation simple (calculer à la main l'équation d'un objet qui tombe et comparer avec bullet)
- Contrôleurs: classe "Controler" -> pattern listener : écoute les sensors et agit sur les actuators
  -> + permettre le contrôle des actuateurs depuis un processus distant ? (socket, rpc, ...)
- Créer une classe "Noise" appliquée aux senseurs/aux actuateurs pour simuler la transposition à la réalité -> pattern wrapper ?

- Améliorer le rendu graphique: régler correctement les matériaux -> faire une appli dédiée OSG_Qt_Lab ?
  + improve shadow technics
- Faire des vidéos et les poster sur jdhp

Copier dans BOTSIM v2.0:
-> Créer des contrôleurs
   -> SAES + sinusoïdes
   -> SAES + convolution de sinusoïdes
   -> SAES + neural net (?)
   -> PID (pendule inversé)
   -> Reinforcement learning
   -> Contrôle manuel via un joypad (pour les robots à roues)
-> Modéliser, créer les objets et créer les contrôleurs pour des robots
   -> Créer un robot à 4 roues
   -> Créer un robot à 2 roues (pendule inversé)
   -> Créer un robot à 4 pattes
   -> Créer un robot à 6 ou 8 pattes
-> Optimisation les contrôleurs -> quelle "interface" dans l'API ?
   -> Permettre d'optimiser les contrôleurs de manière répartie (MPI, OpenMP, ...)

- Améliorer le rendu: fog + LOD
- Améliorer le rendu: GLSL (shaders)
- Améliorer le rendu: motion blur

- Singleton OSG / Bullet ? -> bof...
- Txt infos (hinge constraints, ...)

- Permettre aux objets "Part", etc. d'être chargés dynamiquement sous la forme de plugins
  -> objets décrits en XML 
- Faire une interface graphique pour construire les robots, lancer les simulations et récupérer les résultats interactivement (ie rendre le logiciel utilisable pour le "grand public")
  -> robots décrits en XML (format de sauvegarde)

